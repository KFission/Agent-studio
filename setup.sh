#!/usr/bin/env bash
# ═══════════════════════════════════════════════════════════════════════
# JAI Agent OS — Automated Setup & Install Script
# ═══════════════════════════════════════════════════════════════════════
#
# This script sets up the entire JAI Agent OS platform from scratch:
#   - Checks prerequisites (Docker, Docker Compose)
#   - Generates secrets and creates .env configuration
#   - Builds and starts all services (backend, frontend, Langfuse, etc.)
#   - Waits for all services to be healthy
#   - Seeds the admin user: admin@jaggaer.com / admin123
#   - Verifies everything works end-to-end
#
# Usage:
#   chmod +x setup.sh
#   ./setup.sh
#
# Optional env vars you can set BEFORE running:
#   GOOGLE_API_KEY        - Google Gemini API key (for LLM calls)
#   ANTHROPIC_API_KEY     - Anthropic Claude API key
#   OPENAI_API_KEY        - OpenAI API key
#   GUARDRAILS_TOKEN      - Guardrails AI token
#
# ═══════════════════════════════════════════════════════════════════════

set -euo pipefail

# ── Colors ────────────────────────────────────────────────────────────
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
BOLD='\033[1m'
NC='\033[0m' # No Color

info()    { echo -e "${BLUE}[INFO]${NC}  $*"; }
success() { echo -e "${GREEN}[  OK]${NC}  $*"; }
warn()    { echo -e "${YELLOW}[WARN]${NC}  $*"; }
error()   { echo -e "${RED}[FAIL]${NC}  $*"; }
header()  { echo -e "\n${BOLD}${CYAN}═══ $* ═══${NC}\n"; }

# ── Project root ──────────────────────────────────────────────────────
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
cd "$SCRIPT_DIR"

header "JAI Agent OS — Automated Setup"
echo -e "  Platform directory: ${BOLD}$SCRIPT_DIR${NC}"
echo ""

# ═══════════════════════════════════════════════════════════════════════
# 1. CHECK PREREQUISITES
# ═══════════════════════════════════════════════════════════════════════
header "Step 1: Checking prerequisites"

# Docker
if ! command -v docker &>/dev/null; then
    error "Docker is not installed. Please install Docker first:"
    echo "  https://docs.docker.com/get-docker/"
    exit 1
fi
success "Docker: $(docker --version | head -1)"

# Docker Compose (v2 plugin or standalone)
if docker compose version &>/dev/null; then
    COMPOSE="docker compose"
    success "Docker Compose: $(docker compose version --short 2>/dev/null || echo 'v2')"
elif command -v docker-compose &>/dev/null; then
    COMPOSE="docker-compose"
    success "Docker Compose: $(docker-compose --version | head -1)"
else
    error "Docker Compose is not installed."
    echo "  Install it: https://docs.docker.com/compose/install/"
    exit 1
fi

# Docker running?
if ! docker info &>/dev/null; then
    error "Docker daemon is not running. Please start Docker."
    exit 1
fi
success "Docker daemon is running"

# Check available disk space (need ~5GB)
if command -v df &>/dev/null; then
    AVAIL_MB=$(df -m "$SCRIPT_DIR" | tail -1 | awk '{print $4}')
    if [ "${AVAIL_MB:-0}" -lt 3000 ] 2>/dev/null; then
        warn "Low disk space: ${AVAIL_MB}MB available (recommend 5GB+)"
    else
        success "Disk space: ${AVAIL_MB}MB available"
    fi
fi

# ═══════════════════════════════════════════════════════════════════════
# 2. GENERATE .env CONFIGURATION
# ═══════════════════════════════════════════════════════════════════════
header "Step 2: Configuring environment"

# Generate a Fernet encryption key if not set
generate_fernet_key() {
    python3 -c "from cryptography.fernet import Fernet; print(Fernet.generate_key().decode())" 2>/dev/null \
    || python3 -c "import base64, os; print(base64.urlsafe_b64encode(os.urandom(32)).decode())" 2>/dev/null \
    || echo "yCzNmZ8YjSj7Oog0WuJ9gZevBP48lIs0TMYdTId5KTo="
}

# Generate random secret
random_secret() {
    python3 -c "import secrets; print(secrets.token_urlsafe(32))" 2>/dev/null \
    || openssl rand -base64 32 2>/dev/null \
    || echo "change-me-$(date +%s)"
}

if [ -f .env ]; then
    info ".env already exists — preserving your existing configuration"
    # Ensure critical vars are present
    if ! grep -q "LANGFUSE_PUBLIC_KEY" .env; then
        echo "LANGFUSE_PUBLIC_KEY=pk-lf-jai-agent-os" >> .env
        echo "LANGFUSE_SECRET_KEY=sk-lf-jai-agent-os-secret" >> .env
        info "Added Langfuse API keys to .env"
    fi
    if ! grep -q "ENCRYPTION_KEY" .env || grep -q "ENCRYPTION_KEY=$" .env; then
        FERNET_KEY=$(generate_fernet_key)
        sed -i.bak "s|^ENCRYPTION_KEY=.*|ENCRYPTION_KEY=${FERNET_KEY}|" .env 2>/dev/null || true
        info "Generated encryption key"
    fi
else
    info "Creating .env from template..."

    FERNET_KEY=$(generate_fernet_key)
    NEXTAUTH_SECRET=$(random_secret)
    LANGFUSE_SALT=$(random_secret)

    cat > .env << ENVEOF
# JAI Agent OS — Auto-generated by setup.sh ($(date -Iseconds 2>/dev/null || date))
# Edit this file to add your LLM provider API keys.

# ── LLM Providers (add your keys here) ───────────────────────────────
GOOGLE_API_KEY=${GOOGLE_API_KEY:-}
ANTHROPIC_API_KEY=${ANTHROPIC_API_KEY:-}
OPENAI_API_KEY=${OPENAI_API_KEY:-}

# ── Langfuse Observability ────────────────────────────────────────────
LANGFUSE_HOST=http://localhost:3030
LANGFUSE_PUBLIC_KEY=pk-lf-jai-agent-os
LANGFUSE_SECRET_KEY=sk-lf-jai-agent-os-secret
LANGFUSE_NEXTAUTH_SECRET=${NEXTAUTH_SECRET}
LANGFUSE_SALT=${LANGFUSE_SALT}

# ── Infrastructure ────────────────────────────────────────────────────
REDIS_URL=redis://localhost:6379/0
DATABASE_URL=postgresql+asyncpg://langfuse:langfuse@localhost:5433/agent_studio
ENCRYPTION_KEY=${FERNET_KEY}

# ── Guardrails AI ─────────────────────────────────────────────────────
GUARDRAILS_TOKEN=${GUARDRAILS_TOKEN:-}

# ── LangSmith (optional) ─────────────────────────────────────────────
LANGCHAIN_TRACING_V2=true
LANGCHAIN_ENDPOINT=https://api.smith.langchain.com
LANGCHAIN_API_KEY=
LANGCHAIN_PROJECT=agent-studio
ENVEOF

    success "Created .env with generated secrets"
fi

# ═══════════════════════════════════════════════════════════════════════
# 3. STOP ANY EXISTING CONTAINERS
# ═══════════════════════════════════════════════════════════════════════
header "Step 3: Cleaning up existing containers"

if $COMPOSE ps -q 2>/dev/null | grep -q .; then
    info "Stopping existing containers..."
    $COMPOSE down --remove-orphans 2>/dev/null || true
    success "Existing containers stopped"
else
    info "No existing containers found"
fi

# ═══════════════════════════════════════════════════════════════════════
# 4. BUILD IMAGES
# ═══════════════════════════════════════════════════════════════════════
header "Step 4: Building Docker images"
info "This may take 3-10 minutes on first run..."

$COMPOSE build --parallel 2>&1 | tail -20
success "All Docker images built"

# ═══════════════════════════════════════════════════════════════════════
# 5. START INFRASTRUCTURE (Postgres, Redis)
# ═══════════════════════════════════════════════════════════════════════
header "Step 5: Starting infrastructure"

info "Starting PostgreSQL and Redis..."
$COMPOSE up -d langfuse-db redis 2>&1 | grep -v "^$"

# Wait for Postgres
info "Waiting for PostgreSQL to be ready..."
for i in $(seq 1 30); do
    if docker exec jai-postgres pg_isready -U langfuse &>/dev/null; then
        success "PostgreSQL is ready"
        break
    fi
    if [ "$i" -eq 30 ]; then
        error "PostgreSQL failed to start after 30s"
        exit 1
    fi
    sleep 1
done

# Wait for Redis
for i in $(seq 1 15); do
    if docker exec jai-redis redis-cli ping 2>/dev/null | grep -q PONG; then
        success "Redis is ready"
        break
    fi
    sleep 1
done

# ═══════════════════════════════════════════════════════════════════════
# 5b. CREATE DATABASES & RESTORE BACKUPS
# ═══════════════════════════════════════════════════════════════════════
header "Step 5b: Setting up databases"

info "Creating agent_studio and guardrails databases..."
if docker exec jai-postgres bash -c "export POSTGRES_USER=langfuse POSTGRES_DB=langfuse && bash /docker-entrypoint-initdb.d/init-agent-studio.sh" 2>&1 | grep -q "ready"; then
    success "Databases created (agent_studio, guardrails)"
else
    warn "Database creation may have already been done"
fi

# Restore from SQL backups if they exist
if [ -d "db_backup" ]; then
    info "Checking for SQL backups in db_backup/..."
    
    # Restore agent_studio database
    if [ -f "db_backup/agent_studio.sql" ]; then
        info "Restoring agent_studio database from backup..."
        if docker exec -i jai-postgres psql -U langfuse -d agent_studio < db_backup/agent_studio.sql >/dev/null 2>&1; then
            success "agent_studio database restored from backup"
        else
            warn "Failed to restore agent_studio backup (may be empty or already restored)"
        fi
    else
        info "No agent_studio.sql backup found — using fresh database"
    fi
    
    # Restore guardrails database
    if [ -f "db_backup/guardrails.sql" ]; then
        info "Restoring guardrails database from backup..."
        if docker exec -i jai-postgres psql -U langfuse -d guardrails < db_backup/guardrails.sql >/dev/null 2>&1; then
            success "guardrails database restored from backup"
        else
            warn "Failed to restore guardrails backup (may be empty or already restored)"
        fi
    else
        info "No guardrails.sql backup found — using fresh database"
    fi
    
    # Restore langfuse database
    if [ -f "db_backup/langfuse.sql" ]; then
        info "Restoring langfuse database from backup..."
        if docker exec -i jai-postgres psql -U langfuse -d langfuse < db_backup/langfuse.sql >/dev/null 2>&1; then
            success "langfuse database restored from backup"
        else
            warn "Failed to restore langfuse backup (may be empty or already restored)"
        fi
    else
        info "No langfuse.sql backup found — Langfuse will auto-initialize"
    fi
else
    info "No db_backup/ directory found — using fresh databases"
fi

# ═══════════════════════════════════════════════════════════════════════
# 6. START LANGFUSE (needs Postgres ready first)
# ═══════════════════════════════════════════════════════════════════════
header "Step 6: Starting Langfuse observability"

info "Starting Langfuse (auto-initializes project + API keys)..."
$COMPOSE up -d langfuse 2>&1 | grep -v "^$"

info "Waiting for Langfuse to be healthy (may take 30-60s on first run)..."
for i in $(seq 1 90); do
    if docker exec jai-langfuse wget --no-verbose --tries=1 --spider http://localhost:3000/api/public/health 2>/dev/null; then
        success "Langfuse is healthy"
        break
    fi
    if [ "$i" -eq 90 ]; then
        warn "Langfuse is still starting — continuing anyway (it may need more time)"
        break
    fi
    if [ $((i % 10)) -eq 0 ]; then
        info "  Still waiting... (${i}s)"
    fi
    sleep 1
done

# Verify Langfuse API keys work
sleep 3
LF_STATUS=$(curl -s -o /dev/null -w "%{http_code}" -u "pk-lf-jai-agent-os:sk-lf-jai-agent-os-secret" "http://localhost:3030/api/public/traces?limit=1" 2>/dev/null || echo "000")
if [ "$LF_STATUS" = "200" ]; then
    success "Langfuse API keys are working"
else
    warn "Langfuse API returned $LF_STATUS — keys may not be initialized yet"
    info "Langfuse will auto-initialize on first request from the backend"
fi

# ═══════════════════════════════════════════════════════════════════════
# 7. START GUARDRAILS
# ═══════════════════════════════════════════════════════════════════════
header "Step 7: Starting Guardrails AI"

info "Starting Guardrails service..."
$COMPOSE up -d guardrails 2>&1 | grep -v "^$"
info "Guardrails starting in background (takes 30-60s to initialize)"

# ═══════════════════════════════════════════════════════════════════════
# 7b. START LANGGRAPH SUPERVISOR
# ═══════════════════════════════════════════════════════════════════════
header "Step 7b: Starting LangGraph Supervisor"

info "Starting LangGraph supervisor agent server..."
$COMPOSE up -d langgraph-supervisor 2>&1 | grep -v "^$"

info "Waiting for LangGraph supervisor to be healthy (may take 30-60s)..."
for i in $(seq 1 90); do
    if docker exec langgraph-supervisor python -c "import urllib.request; urllib.request.urlopen('http://localhost:2024/ok')" 2>/dev/null; then
        success "LangGraph supervisor is healthy"
        break
    fi
    if [ "$i" -eq 90 ]; then
        warn "LangGraph supervisor is still starting — continuing anyway"
        break
    fi
    if [ $((i % 10)) -eq 0 ]; then
        info "  Still waiting... (${i}s)"
    fi
    sleep 1
done

# ═══════════════════════════════════════════════════════════════════════
# 8. START BACKEND + FRONTEND
# ═══════════════════════════════════════════════════════════════════════
header "Step 8: Starting Backend & Frontend"

info "Starting backend..."
$COMPOSE up -d backend 2>&1 | grep -v "^$"

info "Waiting for backend to be healthy..."
for i in $(seq 1 60); do
    if curl -sf http://localhost:8080/info &>/dev/null; then
        success "Backend is healthy"
        break
    fi
    if [ "$i" -eq 60 ]; then
        error "Backend failed to start. Check logs: docker logs jai-backend"
        exit 1
    fi
    if [ $((i % 10)) -eq 0 ]; then
        info "  Still waiting... (${i}s)"
    fi
    sleep 1
done

info "Starting frontend + nginx proxy..."
$COMPOSE up -d frontend nginx-proxy 2>&1 | grep -v "^$"

info "Waiting for frontend..."
for i in $(seq 1 30); do
    if curl -sf -o /dev/null http://localhost:3000/ 2>/dev/null; then
        success "Frontend is ready"
        break
    fi
    if [ "$i" -eq 30 ]; then
        warn "Frontend is still starting — it may need a moment"
    fi
    sleep 1
done

# ═══════════════════════════════════════════════════════════════════════
# 9. VERIFY DATABASE SEEDING & ADMIN USER
# ═══════════════════════════════════════════════════════════════════════
header "Step 9: Verifying database seed & admin user"

# The backend auto-seeds on startup via seed_db.py (idempotent).
# If the DB was not reachable at startup or seeding failed silently,
# we detect it here and restart the backend to retry.

SEED_OK=false
for attempt in 1 2 3; do
    LOGIN_RESPONSE=$(curl -s -X POST http://localhost:8080/auth/login \
        -H "Content-Type: application/json" \
        -d '{"username":"admin@jaggaer.com","password":"admin123"}' 2>/dev/null || echo '{}')

    if echo "$LOGIN_RESPONSE" | python3 -c "import sys,json; d=json.load(sys.stdin); assert d.get('access_token')" 2>/dev/null; then
        SEED_OK=true
        success "Admin login verified: admin@jaggaer.com / admin123"
        break
    fi

    if [ "$attempt" -lt 3 ]; then
        warn "DB seed check failed (attempt $attempt/3) — restarting backend to re-seed..."
        $COMPOSE restart backend 2>&1 | grep -v "^$"
        info "Waiting for backend to be ready again..."
        for i in $(seq 1 45); do
            if curl -sf http://localhost:8080/info &>/dev/null; then
                break
            fi
            sleep 1
        done
        sleep 3
    fi
done

if [ "$SEED_OK" = false ]; then
    warn "Admin login check failed after 3 attempts"
    info "The DB may need manual inspection. Check: docker compose logs backend | grep SEED"
    info "You can also re-run: docker compose restart backend"
fi

# ═══════════════════════════════════════════════════════════════════════
# 10. VERIFY ALL SERVICES
# ═══════════════════════════════════════════════════════════════════════
header "Step 10: Final health check"

check_service() {
    local name=$1 url=$2
    if curl -sf -o /dev/null "$url" 2>/dev/null; then
        success "$name"
    else
        warn "$name — not responding yet (may still be starting)"
    fi
}

check_service "PostgreSQL        → localhost:5433" "http://localhost:8080/info"
check_service "Redis             → localhost:6379" "http://localhost:8080/info"
check_service "Langfuse          → localhost:3030" "http://localhost:3030/api/public/health"
check_service "LangGraph         → localhost:2024" "http://localhost:2024/ok"
check_service "Backend API       → localhost:8080" "http://localhost:8080/info"
check_service "Frontend UI       → localhost:3000" "http://localhost:3000"

# Show running containers
echo ""
info "Running containers:"
$COMPOSE ps --format "table {{.Name}}\t{{.Status}}\t{{.Ports}}" 2>/dev/null || $COMPOSE ps

# ═══════════════════════════════════════════════════════════════════════
# DONE
# ═══════════════════════════════════════════════════════════════════════
header "Setup Complete!"

echo -e "${BOLD}${GREEN}
  ╔══════════════════════════════════════════════════════════════╗
  ║                  JAI Agent OS is running!                   ║
  ╠══════════════════════════════════════════════════════════════╣
  ║                                                            ║
  ║  Frontend UI:     http://localhost:3000                    ║
  ║  Backend API:     http://localhost:8080                    ║
  ║  Langfuse UI:     http://localhost:3030                    ║
  ║  API Docs:        http://localhost:8080/docs               ║
  ║                                                            ║
  ╠══════════════════════════════════════════════════════════════╣
  ║  Login Credentials:                                        ║
  ║    Email:     admin@jaggaer.com                            ║
  ║    Password:  admin123                                     ║
  ║                                                            ║
  ╠══════════════════════════════════════════════════════════════╣
  ║  Langfuse Credentials:                                     ║
  ║    Email:     admin@jaggaer.com                            ║
  ║    Password:  admin123                                     ║
  ║                                                            ║
  ╠══════════════════════════════════════════════════════════════╣
  ║  Useful Commands:                                          ║
  ║    docker compose logs -f backend   # Backend logs         ║
  ║    docker compose logs -f frontend  # Frontend logs        ║
  ║    docker compose down              # Stop everything      ║
  ║    docker compose up -d             # Restart all          ║
  ║                                                            ║
  ╚══════════════════════════════════════════════════════════════╝
${NC}"

echo -e "${YELLOW}NOTE:${NC} To use LLM features, add your API keys to ${BOLD}.env${NC}:"
echo "  GOOGLE_API_KEY=your-gemini-api-key"
echo "  Then restart: docker compose up -d backend"
echo ""
